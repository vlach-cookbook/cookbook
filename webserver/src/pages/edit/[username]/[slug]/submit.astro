---
import Layout from "@layouts/Layout.astro";
import {
  parseIntOrUndefined,
  type StructuredFormData,
  structureFormData,
} from "@lib/forms";
import { getLogin } from "@lib/login-cookie";
import { prisma } from "@lib/prisma";
import type { Prisma } from "@prisma/client";
prisma;

const { username, slug } = Astro.params;

const user = await getLogin(Astro.cookies);

const mayEdit = user && user.username === username;
if (!mayEdit) {
  Astro.response.status = 403;
}

let formData: FormData | null = null;
try {
  formData = await Astro.request.formData();
} catch (e) {
  Astro.response.status = 400;
}

type UpdateResult = {
  success: boolean;
  error?: "may-not-edit" | "no-form-data" | "missing-field";
};
async function updateRecipe(): Promise<UpdateResult> {
  if (!mayEdit) {
    return { success: false, error: "may-not-edit" };
  }
  if (!formData) {
    return { success: false, error: "no-form-data" };
  }

  const structuredData = structureFormData(formData);

  const recipeId: number | undefined = parseIntOrUndefined(structuredData.id);

  if (typeof structuredData.name !== "string")
    return { success: false, error: "missing-field" };
  const name = structuredData.name;

  if (!slug) return { success: false, error: "missing-field" };

  const recipeData: Prisma.RecipeUpdateInput & Prisma.RecipeCreateInput = {
    author: { connect: { id: user.id } },
    name,
    slug,
  };

  // parseInt() actually takes any type, but TypeScript doesn't know that.
  const inputServings = parseInt(structuredData.servings as string);
  recipeData.servings = isNaN(inputServings) ? null : inputServings;

  if (structuredData.step instanceof Array) {
    const inputSteps: Array<string | StructuredFormData> = structuredData.step;
    recipeData.steps = inputSteps.filter(
      (step): step is string => typeof step === "string",
    );
  }

  /// Maybe-sparse array of ingredient info.
  const ingredients: Prisma.RecipeIngredientCreateWithoutRecipeInput[] = [];
  if (structuredData.ingredient instanceof Array) {
    let order = 0;
    for (const ingredient of structuredData.ingredient) {
      if (typeof ingredient !== "object" || ingredient instanceof Array)
        continue;

      const name = ingredient.name;
      if (typeof name !== "string") continue;
      const newIngredient: Prisma.RecipeIngredientCreateWithoutRecipeInput = {
        name,
        order: order++,
      };
      if (typeof ingredient.amount === "string" && ingredient.amount.length > 0)
        newIngredient.amount = ingredient.amount;
      if (typeof ingredient.unit === "string" && ingredient.unit.length > 0)
        newIngredient.unit = ingredient.unit;
      if (typeof ingredient.preparation === "string" && ingredient.preparation.length > 0)
        newIngredient.preparation = ingredient.preparation;
      ingredients.push(newIngredient);
    }
  }

  recipeData.ingredients = {
    deleteMany: {},
    // Note https://github.com/prisma/prisma/issues/16606, that the object
    // order determines the order that the changes happen, but that this isn't
    // documented.
    createMany: {
      data: ingredients,
    },
  };

  /// Maybe-sparse array of category names.
  if (structuredData.category instanceof Array) {
    const inputCategories: Array<string | StructuredFormData> =
      structuredData.category;
    const categories = inputCategories
      .filter((category): category is string => typeof category === "string")
      .map((name) => ({ name }));
    // Make sure all the categories exist, because the only way to disconnect removed categories is
    // to use `set:`, which can't create categories, and because connectOrCreate has a race
    // condition anyway
    // (https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#connectorcreate)
    await prisma.category.createMany({
      data: categories,
      skipDuplicates: true,
    });
    // For an existing recipe, use "set" to delete old values. For a new recipe, use "connect"
    // since .create() doesn't accept "set".
    recipeData.categories = { [recipeId ? "set" : "connect"]: categories };
  }

  if (recipeId) {
    // Update the existing recipe.
    const recipeUpdateData: Prisma.RecipeUpdateInput = recipeData;
    // Ensure things don't change unexpectedly.
    delete recipeUpdateData.author;
    delete recipeUpdateData.slug;
    await prisma.recipe.update({
      where: { id: recipeId },
      data: recipeUpdateData,
    });
  } else {
    // Create a new recipe.
    const recipeCreateData: Prisma.RecipeCreateInput = Object.assign(
      recipeData,
      {
        // Strip out the deleteMany and update fields from RecipeUpdateInput.ingredients.
        ingredients: { createMany: recipeData.ingredients.createMany },
      },
    );
    await prisma.recipe.create({
      data: recipeCreateData,
    });
  }
  return { success: true };
}
const result = await updateRecipe();
if (result.success) {
  return Astro.redirect(`/r/${username}/${slug}`, 303);
}
---

<Layout title="Couldn't edit recipe" user={user}>
  <p>
    {
      user
        ? `Welcome, ${user?.name || user?.username}.`
        : `You are not logged in.`
    }
    {
      user?.username === username
        ? null
        : ` Only ${username} may edit this recipe.`
    }
  </p>
  {
    result.error === "no-form-data" ? (
      <p>
        You must submit the <a href={`/edit/${username}/${slug}`}>edit form</a>{" "}
        to change a recipe.
      </p>
    ) : null
  }
  {
    result.error === "missing-field" ? (
      <p>You must provide a name and slug for the recipe.</p>
    ) : null
  }
  <p><a href={`/edit/${username}/${slug}`}>Back to the edit form.</a></p>
</Layout>
