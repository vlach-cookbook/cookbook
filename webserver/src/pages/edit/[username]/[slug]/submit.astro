---
import Layout from "@layouts/Layout.astro";
import { getLogin } from "@lib/login-cookie";
import { prisma } from "@lib/prisma";
import type { Prisma } from "@prisma/client";
import { dset } from "dset";
prisma;

const { username, slug } = Astro.params;

const user = await getLogin(Astro.cookies);

const mayEdit = user && user.username === username;
if (!mayEdit) {
  Astro.response.status = 403;
}

let formData: FormData | null = null;
try {
  formData = await Astro.request.formData();
} catch (e) {
  Astro.response.status = 400;
}

function parseIntOrUndefined(value: unknown) {
  // parseInt() takes all types.
  const result = parseInt(value as string);
  return Number.isNaN(result) ? undefined : result;
}

type StructuredFormData =
  | {
      [key: string]:
        | string
        | StructuredFormData
        | Array<string | StructuredFormData>;
    }
  | StructuredFormData[];

function structureFormData(
  data: FormData
): Exclude<StructuredFormData, StructuredFormData[]> {
  const result: StructuredFormData = {};
  for (const [key, value] of data) {
    // Ignore files.
    if (typeof value === "string") dset(result, key, value);
  }
  return result;
}

type UpdateResult = {
  success: boolean;
  error?: "may-not-edit" | "no-form-data" | "missing-field";
};
async function updateRecipe(): Promise<UpdateResult> {
  if (!mayEdit) {
    return { success: false, error: "may-not-edit" };
  }
  if (!formData) {
    return { success: false, error: "no-form-data" };
  }

  const structuredData = structureFormData(formData);

  const recipeId: number | undefined = parseIntOrUndefined(structuredData.id);

  if (typeof structuredData.name !== "string")
    return { success: false, error: "missing-field" };
  const name = structuredData.name;

  if (!slug) return { success: false, error: "missing-field" };

  const recipeData: Prisma.RecipeUpdateInput & Prisma.RecipeCreateInput = {
    author: { connect: { id: user.id } },
    name,
    slug,
  };

  // parseInt() actually takes any type, but TypeScript doesn't know that.
  const inputServings = parseInt(structuredData.servings as string);
  recipeData.servings = isNaN(inputServings) ? null : inputServings;

  if (structuredData.step instanceof Array) {
    const inputSteps: Array<string | StructuredFormData> = structuredData.step;
    recipeData.steps = inputSteps.filter(
      (step): step is string => typeof step === "string"
    );
  }

  /// Maybe-sparse array of ingredient info.
  const newIngredients: Prisma.RecipeIngredientCreateWithoutRecipeInput[] = [];
  const updatedIngredients = new Map<
    number,
    Prisma.RecipeIngredientUpdateInput
  >();
  if (structuredData.ingredient instanceof Array) {
    let order = 0;
    for (const ingredient of structuredData.ingredient) {
      if (typeof ingredient !== "object" || ingredient instanceof Array)
        continue;

      const ingredientId = parseIntOrUndefined(ingredient.id);
      if (ingredientId === undefined) {
        // New ingredient.
        const name = ingredient.name;
        if (typeof name !== "string") continue;
        const newIngredient: Prisma.RecipeIngredientCreateWithoutRecipeInput = {
          name,
          order: order++,
        };
        if (typeof ingredient.amount === "string")
          newIngredient.amount = ingredient.amount;
        if (typeof ingredient.unit === "string")
          newIngredient.unit = ingredient.unit;
        newIngredients.push(newIngredient);
      } else {
        // Existing ingredient.
        if (updatedIngredients.has(ingredientId)) continue;
        if (typeof ingredient.name !== "string") continue;
        const updatedIngredient: Prisma.RecipeIngredientUpdateInput = {
          order: order++,
        };
        updatedIngredient.name = ingredient.name;
        updatedIngredient.amount =
          typeof ingredient.amount === "string" && ingredient.amount.length > 0
            ? ingredient.amount
            : null;
        updatedIngredient.unit =
          typeof ingredient.unit === "string" && ingredient.unit.length > 0
            ? ingredient.unit
            : null;
        updatedIngredient.preparation =
          typeof ingredient.preparation === "string" &&
          ingredient.preparation.length > 0
            ? ingredient.preparation
            : null;
        updatedIngredients.set(ingredientId, updatedIngredient);
      }
    }
  }

  recipeData.ingredients = {
    deleteMany: { id: { notIn: [...updatedIngredients.keys()] } },
    // Run the create after the delete so that its new ID doesn't get immediately deleted.
    // https://github.com/prisma/prisma/issues/16606
    createMany: {
      data: newIngredients,
    },
    update: [...updatedIngredients.entries()].map(([id, update]) => ({
      where: { id },
      data: update,
    })),
  };

  /// Maybe-sparse array of category names.
  if (structuredData.category instanceof Array) {
    const inputCategories: Array<string | StructuredFormData> =
      structuredData.category;
    const categories = inputCategories
      .filter((category): category is string => typeof category === "string")
      .map((name) => ({ name }));
    // Make sure all the categories exist, because the only way to disconnect removed categories is
    // to use `set:`, which can't create categories, and because connectOrCreate has a race
    // condition anyway
    // (https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#connectorcreate)
    await prisma.category.createMany({
      data: categories,
      skipDuplicates: true,
    });
    // For an existing recipe, use "set" to delete old values. For a new recipe, use "connect"
    // since .create() doesn't accept "set".
    recipeData.categories = { [recipeId ? "set" : "connect"]: categories };
  }

  if (recipeId) {
    // Update the existing recipe.
    const recipeUpdateData: Prisma.RecipeUpdateInput = recipeData;
    // Ensure things don't change unexpectedly.
    delete recipeUpdateData.author;
    delete recipeUpdateData.slug;
    await prisma.recipe.update({
      where: { id: recipeId },
      data: recipeUpdateData,
    });
  } else {
    // Create a new recipe.
    const recipeCreateData: Prisma.RecipeCreateInput = Object.assign(
      recipeData,
      {
        // Strip out the deleteMany and update fields from RecipeUpdateInput.ingredients.
        ingredients: { createMany: recipeData.ingredients.createMany },
      }
    );
    await prisma.recipe.create({
      data: recipeCreateData,
    });
  }
  return { success: true };
}
const result = await updateRecipe();
if (result.success) {
  return Astro.redirect(`/r/${username}/${slug}`, 303);
}
---

<Layout title="Couldn't edit recipe" user={user}>
  <p>
    {
      user
        ? `Welcome, ${user?.name || user?.username}.`
        : `You are not logged in.`
    }
    {
      user?.username === username
        ? null
        : ` Only ${username} may edit this recipe.`
    }
  </p>
  {
    result.error === "no-form-data" ? (
      <p>
        You must submit the <a href={`/edit/${username}/${slug}`}>edit form</a>{" "}
        to change a recipe.
      </p>
    ) : null
  }
  {
    result.error === "missing-field" ? (
      <p>You must provide a name and slug for the recipe.</p>
    ) : null
  }
  <p><a href={`/edit/${username}/${slug}`}>Back to the edit form.</a></p>
</Layout>
