---
import Layout from "@layouts/Layout.astro";
import { getLogin } from "@lib/login-cookie";
import { prisma } from "@lib/prisma";
import slugify from "@lib/slugify";
import type { Recipe,User } from "@prisma/client";
import { PrismaClientKnownRequestError } from "@prisma/client/runtime";

const user = await getLogin(Astro.cookies);

interface JsonRecipe {
  dateCreated?: string;
  name: string;
  recipeCategory?: string[];
  recipeIngredient?: JsonRecipeIngredient[];
  recipeInstructions: string[];
  recipeYield?: string;
  error?: string;
}
interface JsonRecipeIngredient {
  name?: string;
  quantity?: string;
  unit?: string;
  preparation?: string;
}

async function importCategories(recipes: JsonRecipe[]): Promise<void> {
  const categories = new Set<string>();
  for (const recipe of recipes) {
    if (!recipe.recipeCategory) continue;
    for (const category of recipe.recipeCategory) {
      categories.add(category);
    }
  }
  await prisma.category.createMany({
    data: Array.from(categories.keys()).map((name) => ({ name })),
    skipDuplicates: true,
  });
}

function parseOptionalInt(value: string | undefined): number | null {
  if (!value) return null;
  const parsed = Number.parseInt(value);
  if (Number.isNaN(parsed)) return null;
  return parsed;
}

async function createRecipe(recipe: JsonRecipe, user: User): Promise<Recipe> {
  return await prisma.recipe.create({
    data: {
      name: recipe.name,
      author: { connect: { id: user.id } },
      slug: slugify(recipe.name),
      createdAt: recipe.dateCreated ? new Date(recipe.dateCreated) : undefined,
      servings: parseOptionalInt(recipe.recipeYield),
      ingredients: {
        create: recipe.recipeIngredient?.map((ingredient, order) => {
          if (!ingredient.name) throw new Error("Missing ingredient name.");
          return {
            order,
            amount: ingredient.quantity,
            unit: ingredient.unit,
            name: ingredient.name,
            preparation: ingredient.preparation,
          };
        }),
      },
      categories: {
        connect: recipe.recipeCategory?.map((name) => ({ name })),
      },
      steps: recipe.recipeInstructions,
    },
  });
}

type ImportResult =
  | { result: "not-a-post" }
  | { result: "no-user" }
  | { result: "not-a-form-submission" }
  | { result: "no-json"; error: string }
  | {
      result: "some-recipes-malformed" | "success";
      importedRecipes: Recipe[];
      malformedRecipes: JsonRecipe[];
    };

async function importPostedRecipes(): Promise<ImportResult> {
  if (!user) {
    Astro.response.status = 403;
    return { result: "no-user" };
  }
  let recipes: JsonRecipe[];
  try {
    const formData = await Astro.request.formData();
    const recipeField = formData.get("recipes");
    if (recipeField === null || typeof recipeField === "string") {
      Astro.response.status = 400;
      return { result: "not-a-form-submission" };
    }
    recipes = JSON.parse(await recipeField.text());
  } catch (e) {
    Astro.response.status = 400;
    return { result: "no-json", error: String(e) };
  }

  await importCategories(recipes);

  let importResult: ImportResult = {
    result: "success",
    importedRecipes: [],
    malformedRecipes: [],
  };
  let i = -1;
  for (const recipeResult of await Promise.allSettled(
    recipes.map((recipe) => createRecipe(recipe, user))
  )) {
    i++;
    switch (recipeResult.status) {
      case "fulfilled":
        importResult.importedRecipes.push(recipeResult.value);
        break;
      case "rejected":
        if (
          recipeResult.reason instanceof PrismaClientKnownRequestError &&
          recipeResult.reason.code === "P2002"
        ) {
          // The recipe was just already inserted.
          continue;
        }
        importResult.result = "some-recipes-malformed";
        recipes[i]!.error = String(recipeResult.reason);
        importResult.malformedRecipes.push(recipes[i]!);
        break;
    }
  }

  return importResult;
}

let importResult: ImportResult = { result: "not-a-post" };

if (Astro.request.method === "POST") {
  importResult = await importPostedRecipes();
}
---

<script>
  window.addEventListener(
    "DOMContentLoaded",
    () => {
      const invalidRecipesAnchor = document.getElementById("invalid-recipes");
      if (invalidRecipesAnchor) {
        if (!(invalidRecipesAnchor instanceof HTMLAnchorElement))
          throw new Error("Invalid recipes anchor is not an anchor");
        const invalidRecipesFile = new File(
          [invalidRecipesAnchor.dataset.invalidRecipes!],
          "invalid-recipes.json",
          { type: "application/json" }
        );
        invalidRecipesAnchor.href = URL.createObjectURL(invalidRecipesFile);
        delete invalidRecipesAnchor.dataset.invalidRecipes;
      }
    },
    { once: true }
  );
</script>

<Layout title="Import recipes" user={user} needLogin>
  <h1>Import recipes</h1>

  {
    user ? (
      <form method="POST" action="/import" enctype="multipart/form-data">
        <label>
          Upload a file of JSON recipes:
          <input type="file" accept="application/json" name="recipes" />
        </label>
        <button type="submit">Import</button>
      </form>
    ) : (
      <p class="error">Please log in to import recipes.</p>
    )
  }
  {
    importResult.result === "success" ? (
      <p>Success! {importResult.importedRecipes.length} recipes imported.</p>
    ) : importResult.result === "not-a-form-submission" ? (
      <p class="error">Please import recipes using this form.</p>
    ) : importResult.result === "no-json" ? (
      <>
        <pre class="error">{importResult.error}</pre>
        <p class="error">
          Please import a file consisting of a JSON array of recipes that match
          <a href="https://schema.org/Recipe">https://schema.org/Recipe</a>.
        </p>
      </>
    ) : importResult.result === "some-recipes-malformed" ? (
      <p>
        {importResult.importedRecipes.length} recipes imported. Some of the
        recipes you tried to import weren't valid. Look through the
        <a
          id="invalid-recipes"
          data-invalid-recipes={JSON.stringify(
            importResult.malformedRecipes,
            undefined,
            2
          )}
          download="invalid-recipes.json"
        >
          invalid recipes,
        </a>
        fix the errors in their
        <code>error</code> fields, and then re-import them.
      </p>
    ) : null
  }
</Layout>
